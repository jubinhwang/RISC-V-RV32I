`timescale 1ns / 1ps

module instr_mem (
    input  logic [31:0] instr_rAddr,
    output logic [31:0] instr_code
);
    logic [31:0] rom[0:63];

    initial begin
        //for (int i = 0; i < 64; i++) begin
        //    rom[i] = 32'hffff_0000 + i;
        //end
        /*
        rom [0] = 32'h004182B3; //32'b0000_0000_0100_0001_1000_0010_1011_0011; // add x5, x3, x4
        rom [1] = 32'h409403B3; //32'b0100_0000_1001_0100_0000_0011_1011_0011; // sub x7, x8, x9
        // 32'bimm(7bit)_rs2(5bit)_rs1(5bit)_funct(3bit)_imm(5bit)_opcode(7bit)
        //rom [2] = 32'b0000000_00110_00010_010_00001_0100011;
        // B-Type
        //rom[2] 32'b0000000_00010_00010_000_10000_1100011;
        rom[2] = 32'h0021_0863;
        rom[3] = 32'b0000000_00110_00010_001_00010_0100011;
        rom[4] = 32'b0000000_00110_00010_000_00011_0100011;
        // IL_Type
        // 32'b0000 0000 1100_ 0001 0_010_ 0010 1_000 0011;
        // 
        rom[6] = 32'h00C1_2283;  // lw x5, 12(x2)
        // 32'b0000 0000 1100/ 0001 0/000/ 0010 1
        rom[7] = 32'h00C1_1283;
        rom[8] = 32'h00C1_0283;
        rom[9] = 32'h00C1_4283;
        rom[10] = 32'h00C1_5283;

        // I-type
        // 32'b 0000 0000 1100_ 0011 0_000_ 0100 0_001 0011;
        rom[11] = 32'h00C3_0413;  // addi x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_010_ 0100 0_001 0011;
        rom[12] = 32'h00C3_2413;  // slti x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_011_ 0100 0_001 0011;
        rom[13] = 32'h00C3_3413;  // sltiu x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_100_ 0100 0_001 0011;
        rom[14] = 32'h00C3_4413;  // xori x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_110_ 0100 0_001 0011;
        rom[15] = 32'h00C3_6413;  // ori x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_111_ 0100 0_001 0011;
        rom[16] = 32'h00C3_7413;  // andi x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_001_ 0100 0_001 0011;
        rom[17] = 32'h00C3_1413;  // slli x8, x6, 12

        // 32'b 0000 0000 1100_ 0011 0_101_ 0100 0_001 0011;
        rom[18] = 32'h00C3_5413;  // srli x8, x6, 12

        // 32'b 0100 0000 1100_ 0011 0_101_ 0100 0_001 0011;
        rom[19] = 32'h40C3_5413;  // srai x8, x6, 12
        */
        
        //R-Type
        // rom [0] = 32'h004182B3;     // 0
        // rom [1] = 32'h409403B3;     // 4
        // // BEQ 같아서 점프 16만큼 즉 rom [6]로 점프
        // rom[2] = 32'b0000000_00010_00010_000_10000_1100011;     // 8
        // // BNE 달라서 점프 8만큼 즉 rom[9]로 점프  
        // rom[6] = 32'b0000000_00010_00001_001_01000_1100011;     // 24 
        // // rs2 > rs1 8점프 BLT
        // rom[8] = 32'b0000000_00010_00001_100_01000_1100011;    // 32
        // // rs2> rs1 8점프 x BGE
        // rom[10] = 32'b0000000_00010_00001_101_01000_1100011;    // 40
        // // rs1 >= rs2 8점프 BGE
        // rom[11] = 32'b0000000_00010_00010_101_01000_1100011;    // 44
        // // BLTU
        // rom[13] = 32'b0000000_00100_00010_110_01000_1100011;    // 52
        // // BGEU
        // rom[15] = 32'b0000000_00001_00010_101_01000_1100011;    // 60
        
        /* U-type
        // 32'b00000000000000000100_00001_0110111
        rom [1] = 32'b0000_0000_0000_0000_0100_00001_0110111;
        rom [2] = 32'b0000_0000_0000_0000_0100_00010_0010111;
        */
        
        /*
        // J-Type
        // JALR
        // imm = 16, rs4 = 16, rd = 2
        rom[1] = 32'b0000_0001_0000_10000_000_00010_1100111;  
        // JAL 
        // imm = 8, rd = 3
        rom[10] = 32'b0000_0000_1000_0000_0000_00011_1101111;   
        */
        // 무한 재귀 함수
        // 주소 0x08 (rom[2])
        rom[2] = 32'h004000EF; // jal ra, 4  (PC를 +4 하여 0x0C로 점프)
        
        // 주소 0x0C (rom[3])
        rom[3] = 32'hFFC08067; // jalr x0, ra, -4 (ra에 저장된 값에서 -4를 하여 0x08로 점프)
        
        /*
        // --- 프로그램 코드 ---
        // lui x5, %hi(test_data)  ; x5 <- 0x00000000 (test_data 주소의 상위 20비트)
        rom[0] = 32'h000002B7; // 32'b0000_0000_0000_0000_0000_0010_1011_0111
        // addi x5, x5, 28         ; x5 <- x5 + 29 (0x1C). x5는 최종적으로 test_data 주소인 0x1C를 가리킴
        rom[1] = 32'h01D28293; // 32'b0000_0001_1101_/0010_1/000_/0010_1/001_0011
        
        // lb x10, 0(x5)           ; x10 <- M[0x1C] = 0xCD, 부호 확장 -> 0xFFFFFFCD
        rom[2] = 32'h00028503; // 32'b0000_0000_0000_0010_1000_0101_0000_0011
        // lb x11, 1(x5)           ; x11 <- M[0x1D] = 0xAB, 부호 확장 -> 0xFFFFFFAB
        rom[3] = 32'h00128583; // 32'b0000_0000_0001_0010_1000_0101_1000_0011
        // lb x12, 2(x5)           ; x12 <- M[0x1E] = 0x34, 부호 확장 -> 0x00000034
        rom[4] = 32'h00228603; // 32'b0000_0000_0010_0010_1000_0110_0000_0011
        // lb x13, 3(x5)           ; x13 <- M[0x1F] = 0x12, 부호 확장 -> 0x00000012
        rom[5] = 32'h00328683; // 32'b0000_0000_0011_0010_1000_0110_1000_0011
        
        // j .                     ; 무한 루프 (현재 주소로 점프)
        rom[6] = 32'h0000006F; // 32'b0000_0000_0000_0000_0000_0000_0110_1111

        // --- 데이터 영역 ---
        // 주소 0x1C ( = rom[7] ) 위치에 테스트 데이터 저장
        rom[7] = 32'h1234ABCD; // 32'b0001_0010_0011_0100_1010_1011_1100_1101
        */
        /*
        // --- 검증 스크립트 시작 ---
        // =================================================================
        // 1. 준비 단계: 레지스터 초기 설정
        // =================================================================
        // x5 (a5) = 테스트할 메모리의 기본 주소 (0x80000000)
        // x6 (a6) = 메모리에 저장할 데이터 값
        // 1000_0000_0000_0000_0000_0010_1011_0111
        // lui x5, 0x80000
        rom[0]  = 32'h800002b7;
        rom[1]  = 32'h11112337;
        rom[2]  = 32'h22230313;
        rom[3]  = 32'h0062a023;
        rom[4]  = 32'h0002a503;
        rom[5]  = 32'haa00313;
        rom[6]  = 32'h00628223;
        rom[7]  = 32'h00428583;
        rom[8]  = 32'h0042c603;

        // =================================================================
        // 4. Half-word (16비트) 테스트: 최종 수정된 부분
        // =================================================================
        // 목표: 가장 간단하고 확실한 음수 -1 (0xFFFFFFFF)로 테스트
        rom[9]  = 32'hfff00313;  // addi x6, zero, -1    ; x6 레지스터에 -1 (0xffffffff) 로드
        
        rom[10] = 32'h00629423;  // sh x6, 8(x5)         ; [0x80000008] 주소에 0xFFFF 저장
        rom[11] = 32'h00829683;  // lh x13, 8(x5)        ; -> x13 레지스터로 부호 확장 로드
        rom[12] = 32'h0082d703;  // lhu x14, 8(x5)       ; -> x14 레지스터로 부호 없이 로드
        */
    end

    assign instr_code = rom[instr_rAddr[31:2]];

endmodule
